# 软件单元测试入门与实践

![封面](./images/封面.png)

## 软件测试基础知识

### 什么是软件测试？

> 《GB/T15532 计算机软件测试规范》中对软件测试给出了定义：软件测试的目的是验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、软件需求规格说明、软件设计说明和软件产品说明等规定的软件质量要求；通过测试发现软件缺陷；为软件产品的质量评价提供依据。  

### 测试与调试的区别?

测试并不等于调试。测试需要有组织有计划的进行，其目的是为了发现缺陷并为软件产品的质量评价提供依据，而调试只是为了定位缺陷。

### 软件测试有效性

Glenford J . Myers在《The Art of Software Testing》一书中提到软件测试的目的：

+ 测试是为了证明程序有错，而不是证明程序无错；
+ 一个好的测试用例是在于它能发现至今未发现的错误；
+ 一个成功的测试是发现了至今未发现的错误的测试。

*那么没有发现缺陷的测试是有效测试吗？*
《GB/T 25000.10 系统与软件工程系统与软件质量要求和评价(SQuaRE) 第10部分：系统与软件质量模型》中，从**功能性、性能效率、兼容性、易用性、可靠性、信息安全性、维护性、可移植性**八个方面来评价软件的质量。只要在测试完成后有足够的证据证明软件符合这八个方面的要求，那么测试就是有效的。

### 谁为软件质量负责

从软件测试的二八原则来看，开发人员应该能够发现软件中80%的缺陷；而在开发人员未能发现的20%中，测试人员能够发现其中80%的缺陷；剩下4%的缺陷可能在用户使用过程中被发现，也有可能永远不会被发现。

### 软件测试分类

按照不同阶段分类：

+ **单元测试**：单元测试是针对软件设计的最小单位进行测试，这里的最小单位可以是模块，或面向对象编程中的类。目的是检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误。

+ **集成测试**：集成测试又称为组装测试。在单元测试的基础上，将各个程序单元进行有序、递增的组合测试。目的是验证软件单元之间、软件单元和已集成的软件系统之间的接口关系，并验证已集成的软件系统是否符合设计要求。

+ **确认测试**：确认测试是对已完成集成的软件系统进行测试。目的是验证软件系统本身是否与需求规格说明书中的要求一致。

+ **系统测试**：系统测试是在真实或模拟系统运行的环境下对集成了硬件和软件的系统进行测试。目的是检验系统在真实工作环境下的运行情况，以验证完整的软硬件系统能否实现用户的实际需求。
  
+ **验收测试**：验收测试是按照项目任务书或合同、供需双方约定的验收依据文档对整个系统进行测试以确定系统是否达到验收标准。验收测试的结论作为需要方是否接受该软件的主要依据。

按照是否需要了解内部结构划分：

+ **黑盒测试**：黑盒测试又称为数据驱动测试。在不了解软件的内部结构情况下，根据软件需求说明书中的要求设计测试用例，输入测试数据并验证输出结果，以验证软件表现是否与需求规格说明书中的要求一致。
  
+ **白盒测试**：白盒测试又称为逻辑驱动测试。对软件的结果进行分析，并设计测试用例，对软件的结构和执行路径进行检查，以验证软件是否能够按照设计说明书中的描述正常执行。

+ **灰盒测试**：灰盒测试也是一种数据驱动测试。与黑盒测试不同的是，根据需求规格说明书设计测试用例后，通过了解软件的内部结构补充测试用例，以提高测试的覆盖率。

***

## 单元测试概述

### 什么是单元测试

>单元测试是针对软件设计的最小单位进行测试。单元测试的“单元”在《GB/T15532 计算机软件测试规范》中的解释为“可独立编译或汇编的程序模块”。在实际操作中，可以认为承担一个单一职责的功能模块可以称为一个单元。

在C++中，通常情况下一个类会承担一个单一的职责，那么按类来划分单元是相对比较合理的。在C语言中，通常情况下一个文件中的代码会承担单一的职责，那么按文件来划分单元是相对比合理的。当然这不是绝对的，一个单元不能承担过多的指责，一个单元不能依赖太多其他的单元。

### TDD概述

**TDD全称测试驱动开发（Test-Driven Development）**，是一种增量式软件开发技术。即在没有失败的单元测试的前提下不可以写产品代码，开发产品代码的目的仅仅是为了让测试通过，依靠测试来推动开发的过程。

TDD开发过程如下：

+ 编写一个新的测试用例；
+ 编译代码，可能编译不通过；
+ 对功能代码做一部分改动，使得编译通过；
+ 运行所有测试，这时只有新的测试用例不通过；
+ 修改代码，让最新的测试用例通过；
+ 运行所有测试，确保所有测试用例通过；
+ 对代码进行重构，消除重复设计。

TDD可以帮助开发者解决很多没有单元测试的问题，然而TDD自身的缺点是显而易见的。首先是扭曲了开发的目标；其次让开发者做了很多无用功；最后TDD让开发者轻设计、重重构。

### 单元测试技术要求

在《GB/T15532 计算机软件测试规范》对单元测试做出了如下要求：

+ 对软件设计文档规定的软件单元的功能、性能、接口等应逐项进行测试；
+ 每个软件特性应至少被一个正常测试用例和一个被认可以异常测试用例覆盖；
+ 测试用例的输入应至少包含有效等价类、无效等价类和边界数据值；
+ 在对软件进行动态测试之前，一般应对软件单元的源代码进行静态测试；
+ 语句覆盖率达到100%；
+ 分支覆盖率达到100%；
+ 对输出数据及其格式进行测试。

***

## 静态测试

### 静态测试概述

> 静态测试是在不运行软件的情况下对软件进行测试。通过对程序代码和文档进行检查，以发现可能存在的错误。

静态测试可以从编码规则检查、代码结构分析和代码评审三个方面来进行。编码规则检查是将在编码过程中的一些注意事项形成规则并使用相关的工具进行检查；代码结构分析是使用工具对代码结构进行分析，避免代码过于复杂；代码评审则是由人对代码进行阅读，以发现代码中的一些潜在的错误。

### 编码规则检查

一般来说，将编译器的*警告等级设置到最高时*能够发现大部分的问题，所以在开发过程中首先需要将编译器的警告等级设置到最高然后消除编译器报告的所有警告。消除了编译器的所有警告后，代码可靠性已经是比较高的了，如果需要进一步提高代码的可靠性，可以通过专业的编码规则检查工具进一步检查。
可以选择**pc-lint**作为编码规则检查工具。与其他工具相比，**pc-lint**的检查更为全面，其中也集成了很多的行业标准。

### 预防Bug的十大编码规则

规则1：始终使用大括号
规则2：尽可能使用const关键字
规则3：尽可能使用static关键字
规则4：尽可能使用volatile关键字
规则5：不要注释掉代码
规则6：使用固定宽度的类型
>开发者在编写代码的过程中应该使用固定宽度的数据类型（int8_t，int16_t，int32_t，int64_t），以方便代码移植。

规则7：不要使用移位运算操作有符号数
规则8：有符号和无符号类型不要混用
规则9：尽量不要使用函数功能的宏
规则10：每行只定义一个变量

### 代码结构分析

在编写代码时，要求要结构清晰、接口简单。使用**SourceMonitor**作为代码结构检查工具。
![sourceMonitor](./images/sourceMonitor1.PNG)
然后在右键菜单中选择*Display CheckPoint Metrics Kiviat Graph*，查看某个检车点是否超标？
![sourceMonitor](./images/sourceMonitor2.PNG)

## 代码评审

代码评审有**代码走查**和**代码审查**两种方式。
> 代码走查是在评审人员充分理解了程序的意图后，设计测试用例，并由人充当计算机的角色，模拟计算机运行程序，以发现程序中的逻辑错误。

**代码走查**：

+ 首先将评审的材料发送给评审小组相关的成员，让评审小组充分理解程序的意图。评审材料包括需求文档、设计文档和软件代码。
+ 在评审小组各成员充分理解程序的意图后，设计测试用例，以小组为单位充当计算机的角色，按照测试用例的要求模拟计划机运行程序，在运行过程中大家进行必要的讨论。

代码走查与动态测试类似，都是使用测试用例运行程序。其区别是，代码走查并不是真正运行程序，而是以人充当计算机的角色模拟运行程序，能够很容易的覆盖到动态测试由于条件限制无法模拟的情况，但对人的逻辑思维能力要求也会比较高。

> 代码审查是评审员在充分理解了程序的意图后，通过阅读程序代码或由开发者讲解代码的方式，以发现程序中潜在的错误。

**代码审查**：

+ 需求确认：审查的第一项内容是程序代码是否正确实现了需求文档中的要求。
+ 设计确认：审查的第二项内容是程序是否与设计文档中的要求相符。
+ 代码规范：在确保程序代码正确实现需求且与设计文档相符后，接下来就可以对照代码规范对代码进行评审了。
+ 讨论环节：代码的效率足够高吗？代码的安全性足够高吗？代码方便后续维护吗？代码方便后续扩展吗？代码方便在其他项目中复用吗？代码是否考虑到了所有的异常情况？

**什么时候评审**？
建议的做法是从项目一开始编码就进行代码评审，每天下班前进行一次评审，针对当天编写或修改的代码。这种方式下每次评审的代码量不会很多，更容易达到效果；另外由于较早的开始进行评审，能够及时发现问题并进行修改，也能够更快的帮助开发者养成良好的编程习惯，尽可能的减少代码的返工率。

**评审哪些代码**？
在进行代码评审的时候，功能代码需要进行代码走查和代码审查，而测试代码需要进行代码审查。
***

## 测试用例设计

什么是测试用例？
> 一个测试用例描述了测试人员模拟用户使用系统的一个场景。在这个场景中，测试人员模拟用户的输入，并检测系统的输出是否与用户的期待输出是否一致。

在测试的过程中，实际上就是要控制被测模块的输入，检查被测模块的输出。所以输入输出的定义在测试过程中是至关重要的，如果输入输出定义错了，那么测试将变得无意义。
![输入输出定义](./images/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E5%AE%9A%E4%B9%89.PNG)

### 逻辑覆盖

什么是逻辑覆盖？
> 逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法，其目的是为了尽可能的覆盖程序的语句以及不同的判定条件。

+ **语句覆盖**的含义是，选择足够多的测试数据，使得程序中的每种语句都至少被执行一次。
+ **判定覆盖**的含义为，选择足够多的测试数据，使得程序中的每个判断语句至少出现一次真值和一次假值。
+ **条件覆盖**的定义为，当一个判定语句由多个条件组合而成时，选择足够多的测试数据，使得每一判定语句中的每个逻辑条件的可能的值至少出现一次。
+ **条件组合覆盖**的含义是，当一个判定语句由多个条件组合而成时，选择足够多的测试数据，使得各个条件的各种可能的组合都出现一次。

条件组合覆盖是覆盖率最高的一种逻辑覆盖方法。条件组合覆盖的缺点是测试数据的数量会很多。

**修正条件判定覆盖**的含义是，画出程序的控制流，选择足够多的测试数据，使得程序控制流中的每一条路径都执行一次。
![修正条件判定覆盖](./images/%E4%BF%AE%E6%AD%A3%E6%9D%A1%E4%BB%B6%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96.PNG)

### 数据覆盖

逻辑覆盖能够有效的发现问题。然而逻辑覆盖自身的缺点也是非常明显的。在使用逻辑覆盖的方法设计测试用例时，对实现的依赖性太高，以至于开发者很难考虑到代码本身没有考虑到的地方。

所以在进行单元测试的过程中，除了要使用逻辑覆盖之外，还需要使用另外的方法，那就是数据覆盖。只有两种方法同时使用，相互补充，才能最大限度的提高测试的覆盖率。

**边界值分析**在黑盒测试中经常被用到，在单元测试中也可以使用边界值分析来设计测试用例。通过大量的测试工作经验得知，应用程序往往容易在处理边界条件时发生错误，所以在测试过程中，通常也可以使用边界条件进行测试，只要边界条件没有问题，那么在数据范围内部出现问题的可能性是非常小的。
![分界点](./images/%E5%88%86%E7%95%8C%E7%82%B9.PNG)

输入值可以分为几个不同的集合，每个集合触发不同的处理流程，而每个集合中的各个值也不一定是连续的，在这种情况下无法直接使用边界值进行分析，那么就需要使用到**等价类划分**。

当输入值可以划分为几个不同的集合，而每个集合又触发不同的处理流程时，那么每个集合就可以称为一个等价类，从一个等价类中选取少量的用例就可以代表该等价类中所有可能的输入。

在有些时候，被测单元可能的输入值为有限个离散的值，而一时之间又很难找出规律。在这种情况下可以对所有可能的输入值进行**穷举**，以达到完全覆盖。
***

## 测试准备工作

### 单元测试框架

什么是单元测试框架？
> 单元测试框架是一个软件包，它能够让开发者比较方便的表达产品代码需要表现出什么样的行为。单元测试框架提供了一个自动化单元测试的解决方案，让开发者把更多的精力放在测试用例的设计的编写上，而不用花精力考虑如何对测试用例进行组织。

单元测试框架提供了以下功能：

+ 用于表达一个测试用例的通用语言；
+ 用于表达测试用例的期望结果的通用语言；
+ 对所有的测试用例进行有效的管理；
+ 提供运行部分或全部测试用例的机制；
+ 对于测试通过和失败给出明确的提示；
+ 对于失败的测试用例给出详细的报告；
+ 对各个测试用例的结果进行统计分析。
  
### gtest框架

gtest是google公司开发的一个开源的单元测试框架，基于C++开发，可以对C++语言和C语言进行单元测试。gtest有以下特点：

+ 提供强大的断言集，支持布尔型、整型、浮点型、字符串以及所有实现了比较运算符和输出运算符的自定义类的判断；
+ 提供断言扩展功能，当所需要的断言在gtest中没有提供时，可以使用gtest提供的方法进行扩展；
+ gtest会自动收集我们的测试用例，开发者不需要对测试用例进行组织；
+ 提供死亡测试的功能，用于测试代码在特定情况下异常崩溃的情况；
+ 可将公共的用例初始化和清理工作放入测试夹具中，由gtest自动调用；
+ 使用参数化自动生成多个相似的测试用例。

gtest可以通过[gtest源码](https://github.com/google/googletest/releases/tag/release-1.8.0)获取。
下载源码解压后，可以得到*googlemock*和*googletest*两个目录文件，其中*googletest*的内容就是gtest的源码及相关的项目文件。
![gtest目录文件](./images/gtest%E6%BA%90%E6%96%87%E4%BB%B6.PNG)

### Visual Studio 2013测试环境搭建

什么是库文件？
> 在实际编程的时候，通常需要对部分代码进行复用。可以把需要复用的代码单独进行编译，得到的文件就是库文件。库文件可以分为**静态库**和**动态库**。

**静态库**由一个lib文件（后缀名为.lib）组成，其中包含了对应代码的具体的实现。在编写应用程序时，只需要将lib文件链接到应用程序中就可以使用它的功能了;**动态库**由一个dll文件（后缀名为.dll）和一个lib文件组成，dll文件包含了对应代码的具体实现，而lib文件则包含了对应代码的入口地址。需要将lib文件链接到应用程序中，应用程序在启动后加载对应的dll文件，就可以使用它的功能了。

无论是静态运行库还是动态运行库，Visual Studio都提供了**Debug版本**和**Release版本**。其中Debug版本的运行库中包含了调试信息，Release版本的运行库中不包含调试信息；Debug版本的运行库是没有经过代码优化的，Release版本的运行是经过代码优化的。

[vs2019自带googleTest框架，只需要在工程中使能。](https://blog.csdn.net/weixin_43856003/article/details/105833925?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105833925-blog-124660326.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105833925-blog-124660326.pc_relevant_aa&utm_relevant_index=5)

## 编写测试代码

### 测试入口-main函数

```C
#include <gtest/gtest.h>

int main(int argc, char** argv)
{
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

testing::InitGoogleTest(&argc, argv)是使用命令行参数来初始化gtest。

### 表达测试用例的通用语言

测试用例
> 测试用例是为了验证代码的行为与预期是否相符而进行的一系列活动，在单元测试中，这一系列的活动依靠代码来完成。

测试用例集
> 测试用例集是多个相似或相关的测试用例的集合，是为了方便对测试用例进行管理而产生的一个概念。通俗一点讲，测试用例集就是对测试用例进行分组。

在gtest中，使用test case表示测试用例集，test表示测试用例，要注意区别。

### 通用的判断机制

测试用例的三大要素是**前提条件**、**操作步骤**和**预期结果**。测试用例是否通过的标准就是实际结果与预期结果是否相符，实际结果与预期结果相符则测试通过，实际结果与预期结果不相符则测试不通过。

gtest中判断实际结果与预期结果是否相符的机制称为断言。gtest提供了判断各种简单类型数据的断言，包括布尔类型、整数类型、浮点数类型、字符串等。

**布尔类型**判断
![布尔类型判断](./images/%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.PNG)

```C
TEST(IsLeapYearTest, leapYear)
{
    EXPECT_TRUE(IsLeapYear(2000));
    EXPECT_TRUE(IsLeapYear(1996));   
}

TEST(IsLeapYearTest, commonYear)
{
    EXPECT_TRUE(IsLeapYear(1999));
    EXPECT_TRUE(IsLeapYear(2100));   
}
```

**数值类型**判断
![数值类型判断](./images/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.PNG)

```C
TEST(IntSwapTest, swapSuccess)
{
    int a = 1;
    int b = 2;
    int_swap(&a, &b);
    EXPECT_EQ(2, a);
    EXPECT_EQ(1, b);   
}

TEST(IsLeapYearTest, commonYear)
{
    int a = 1;
    int_swap(&a, NULL);
    EXPECT_EQ(1, a);
    int_swap( NULL, &a);
    EXPECT_EQ(1, a); 
}
```

**浮点数**判断
![浮点数判断](./images/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD.PNG)

```C
TEST(SqrtTest, normalTest)
{
    EXPECT_NEAR(1e-50, sqrt(1e-100), 1e-12);
    EXPECT_NEAR(1, sqrt(1), 1e-12);
    EXPECT_NEAR(1e50, sqrt(1e100), 1e-12);   
}
```

**字符串**判断
![字符串1判断](./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD1.PNG)
![字符串2判断](./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD2.PNG)

```C
TEST(ByteSwapTest, stringSwap)
{
    char str1[10] = "123456789";
    char str2[10] = "abcdefghi";
    byte_swap(str1, str2, 5);
    EXPECT_STREQ("abcde6789", str1);
    EXPECT_STREQ("12345fghi", str2);
}
    
TEST(ByteSwapTest, paramError)
{
   char str1[10] = "123456789";
   char str2[10] = "abcdefghi";
   byte_swap(str1, NULL,5);
   byte_swap(NULL, str2,5);
   byte_swap(str1 str2, 0);
   EXPECT_STREQ("123456789", str1);
   EXPECT_STREQ("abcdefghi", str2); 
}
```

**异常**判断
![字符串1判断](./images/%E5%BC%82%E5%B8%B8%E5%88%A4%E6%96%AD.PNG)

```C
TEST(SqrtTest, overRange)
{
    EXPECT_THROW(sqrt(1.00000001e100), int);
    EXPECT_THROW(sqrt(9.99999999e-101), int);
    EXPECT_THROW(sqrt(0), int);
    EXPECT_THROW(sqrt(-1), int);
}
```

在有些时候，当断言判断失败时，开发者可能需要附加输出一些信息以方便定位Bug。gtest在定义断言时重载了“<<”运算符，可以使用该运算符在gtest的输出信息中加入需要的信息。

```C
TEST(IsLeapYearTest, leapYear)
{
    EXPECT_TRUE(IsLeapYear(2000)) << "expect 2000 is leapyear";
    EXPECT_TRUE(IsLeapYear(1996)) << "expect 1996 is leapyear";   
}

TEST(IsLeapYearTest, commonYear)
{
    EXPECT_TRUE(IsLeapYear(1999)) << "expect 1999 is commonyear";
    EXPECT_TRUE(IsLeapYear(2100)) << "expect 2100 is commonyear";   
}
```

**自定义断言**
![自定义断言](./images/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80.PNG)

```C
void bubblesort(int* data, int len)
{
    int tem = 0;

    for (size_t i = 0; i < len; i++)
    {
        for (size_t j = i+1; j < len; j++)
        {
            if (data[i] > data[j])
            {
                tem = data[i];
                data[i] = data[j];
                data[j] = tem;
            }
        }
    }
}

bool ArrayCompare(const int *exp, const int *act, int len)
{
    bool flag = true;
    for (int i = 0; i < len; i++)
    {
        if (exp[i] != act[i])
        {
            flag = false;
            break;
        }
    }
    return flag;
}

TEST(BubbleSortTest, normalTest) 
{
    int expArray[5] = { 1, 2, 3, 4, 5};
    int actArray[5] = { 3, 1, 5, 4, 2 };

    bubblesort(actArray, 5);
    EXPECT_PRED3(ArrayCompare, expArray, actArray, 5);
}
```

可以使用**EXPECT_PRED3**来实现自定义断言以对数组进行比较，3的意思就是比较函数的参数为3个。使用**EXPECT_PRED3**时，第一个参数是比较函数的名字，之后三个参数是传入到比较函数的参数。

EXPECT开头和ASSERT开头对比
实际上，每一个EXPECT开头的断言都有一个对应的ASSERT开头的判断，例如EXPECT_EQ对应的有ASSERT_EQ。在使用EXPECT系列断言时，当判断失败时，gtest会继续后面的操作，这样就能一次性发现更多的错误。在某些时候，当判断失败时，gtest不需要再进行后续的操作，例如先判断指针是否为空再判断指针指向的内容，显然当指针为空时不需要再判断指针指向的内容。那么在这种情况下就可以使用ASSERT系列断言。值得注意的是，ASSERT系列断言在判断失败时不一定是结束当前用例，而是结束当前函数。

### 测试夹具

在编写一些比较复杂的用例时，通常会进行以下四个步骤的工作：

+ **初始化环境**：在编写测试用例时，有些用例需要在某些特定的前提条件下执行，所以需要进行初始化操作使系统处于特定的状态以便执行测试用例；
+ **运行**：使用特定的数据运行被测试代码；
+ **验证结果**：测试代码运行结束后对被测试代码返回的数据进行验证；
+ **清理现场**：为了不影响其他用例的执行，测试完成后需要将系统状态还原到初始状态。
  
当需要在一个用例集中每一个用例执行之前都进行初始化操作，在每一个用例执行之后都进行清理操作，那么可以将这部分操作放入测试夹具中。

```C++
class CSlistTest: public testing::Test
{
public:
    virtual void SetUp()
    {
        m_head.p_next = &m_node1;
        m_node1.p_next = &m_node2;
        m_node2.p_next = &m_node3;
        m_node3.p_next = NULL;
    }
    virtual void TearDown()
    {

    }
    slist_head_t m_head;
    slist_node_t m_node1;
    slist_node_t m_node2;
    slist_node_t m_node3;
};
```

测试夹具代码。

```C++
TEST_F(CSlistTest, getFirstNext)
{
    EXPECT_EQ(&m_node2, slist_next_get(&m_head, &m_node1));
}
TEST_F(CSlistTest,getLastNext)
{
    EXPECT_EQ(NULL, slist_next_get(&m_head, &m_node3));
}
```

在某些情况下，并不需要在每个用例执行前后都进行初始化和清理操作，只需要在用例集执行前进行初始化操作，在用例集执行后进行清理操作即可。

```C++
class CSlistTest: public testing::Test
{
public:
    virtual void SetUpTestCase()
    {
        m_head.p_next = &m_node1;
        m_node1.p_next = &m_node2;
        m_node2.p_next = &m_node3;
        m_node3.p_next = NULL;
    }
    virtual void TearDownTestCase()
    {

    }
    slist_head_t m_head;
    slist_node_t m_node1;
    slist_node_t m_node2;
    slist_node_t m_node3;
};
slist_head_t CSlistTest::m_head;
slist_head_t CSlistTest::m_node1;
slist_head_t CSlistTest::m_node2;
slist_head_t CSlistTest::m_node3;
```

在某些情况下，不需要在每个用例执行前进行初始化和清理操作，也不需要在每个用例集执行前后都进行初始化和清理操作。只需要在整个测试开始之前执行初始化操作，在整个测试结束后执行清理操作，在这种情况下可以使用全局测试夹具来完成。

```C++
class GlobalEnvironment : public testing::Environment
{
public:
    virtual void SetUp()
    {
        //todo:测试开始前的初始化动作
    }
    virtual void TearDownTestCase()
    {
        //todo：测试结束后的清理动作
    }
};
```

要使用全局测试夹具，只需要在main函数中调用RUN_ALL_TESTS()之前添加如下的代码即可：

```C++
testing :: AddGlobalTestEnvironment(new GlobalEnvironment( ));
```

在进行初始化操作时，执行顺序是全局初始化→用例集初始化→用例初始化；在进行清理操作时，执行顺序是用例清理→用例集清理→全局清理。
![测试夹具的动作顺序](./images/%E6%B5%8B%E8%AF%95%E5%A4%B9%E5%85%B7%E4%B8%AD%E5%90%84%E5%8A%A8%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.PNG)
