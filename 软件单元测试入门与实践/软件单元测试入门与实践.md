# 软件单元测试入门与实践

![封面](./images/封面.png)

## 软件测试基础知识

### 什么是软件测试？

> 《GB/T15532 计算机软件测试规范》中对软件测试给出了定义：软件测试的目的是验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、软件需求规格说明、软件设计说明和软件产品说明等规定的软件质量要求；通过测试发现软件缺陷；为软件产品的质量评价提供依据。  

### 测试与调试的区别?

测试并不等于调试。测试需要有组织有计划的进行，其目的是为了发现缺陷并为软件产品的质量评价提供依据，而调试只是为了定位缺陷。

### 软件测试有效性

Glenford J . Myers在《The Art of Software Testing》一书中提到软件测试的目的：

+ 测试是为了证明程序有错，而不是证明程序无错；
+ 一个好的测试用例是在于它能发现至今未发现的错误；
+ 一个成功的测试是发现了至今未发现的错误的测试。

*那么没有发现缺陷的测试是有效测试吗？*
《GB/T 25000.10 系统与软件工程系统与软件质量要求和评价(SQuaRE) 第10部分：系统与软件质量模型》中，从**功能性、性能效率、兼容性、易用性、可靠性、信息安全性、维护性、可移植性**八个方面来评价软件的质量。只要在测试完成后有足够的证据证明软件符合这八个方面的要求，那么测试就是有效的。

### 谁为软件质量负责

从软件测试的二八原则来看，开发人员应该能够发现软件中80%的缺陷；而在开发人员未能发现的20%中，测试人员能够发现其中80%的缺陷；剩下4%的缺陷可能在用户使用过程中被发现，也有可能永远不会被发现。

### 软件测试分类

按照不同阶段分类：

+ **单元测试**：单元测试是针对软件设计的最小单位进行测试，这里的最小单位可以是模块，或面向对象编程中的类。目的是检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误。

+ **集成测试**：集成测试又称为组装测试。在单元测试的基础上，将各个程序单元进行有序、递增的组合测试。目的是验证软件单元之间、软件单元和已集成的软件系统之间的接口关系，并验证已集成的软件系统是否符合设计要求。

+ **确认测试**：确认测试是对已完成集成的软件系统进行测试。目的是验证软件系统本身是否与需求规格说明书中的要求一致。

+ **系统测试**：系统测试是在真实或模拟系统运行的环境下对集成了硬件和软件的系统进行测试。目的是检验系统在真实工作环境下的运行情况，以验证完整的软硬件系统能否实现用户的实际需求。
  
+ **验收测试**：验收测试是按照项目任务书或合同、供需双方约定的验收依据文档对整个系统进行测试以确定系统是否达到验收标准。验收测试的结论作为需要方是否接受该软件的主要依据。

按照是否需要了解内部结构划分：

+ **黑盒测试**：黑盒测试又称为数据驱动测试。在不了解软件的内部结构情况下，根据软件需求说明书中的要求设计测试用例，输入测试数据并验证输出结果，以验证软件表现是否与需求规格说明书中的要求一致。
  
+ **白盒测试**：白盒测试又称为逻辑驱动测试。对软件的结果进行分析，并设计测试用例，对软件的结构和执行路径进行检查，以验证软件是否能够按照设计说明书中的描述正常执行。

+ **灰盒测试**：灰盒测试也是一种数据驱动测试。与黑盒测试不同的是，根据需求规格说明书设计测试用例后，通过了解软件的内部结构补充测试用例，以提高测试的覆盖率。

***

## 单元测试概述

### 什么是单元测试

>单元测试是针对软件设计的最小单位进行测试。单元测试的“单元”在《GB/T15532 计算机软件测试规范》中的解释为“可独立编译或汇编的程序模块”。在实际操作中，可以认为承担一个单一职责的功能模块可以称为一个单元。

在C++中，通常情况下一个类会承担一个单一的职责，那么按类来划分单元是相对比较合理的。在C语言中，通常情况下一个文件中的代码会承担单一的职责，那么按文件来划分单元是相对比合理的。当然这不是绝对的，一个单元不能承担过多的指责，一个单元不能依赖太多其他的单元。

### TDD概述

**TDD全称测试驱动开发（Test-Driven Development）**，是一种增量式软件开发技术。即在没有失败的单元测试的前提下不可以写产品代码，开发产品代码的目的仅仅是为了让测试通过，依靠测试来推动开发的过程。

TDD开发过程如下：

+ 编写一个新的测试用例；
+ 编译代码，可能编译不通过；
+ 对功能代码做一部分改动，使得编译通过；
+ 运行所有测试，这时只有新的测试用例不通过；
+ 修改代码，让最新的测试用例通过；
+ 运行所有测试，确保所有测试用例通过；
+ 对代码进行重构，消除重复设计。

TDD可以帮助开发者解决很多没有单元测试的问题，然而TDD自身的缺点是显而易见的。首先是扭曲了开发的目标；其次让开发者做了很多无用功；最后TDD让开发者轻设计、重重构。

### 单元测试技术要求

在《GB/T15532 计算机软件测试规范》对单元测试做出了如下要求：

+ 对软件设计文档规定的软件单元的功能、性能、接口等应逐项进行测试；
+ 每个软件特性应至少被一个正常测试用例和一个被认可以异常测试用例覆盖；
+ 测试用例的输入应至少包含有效等价类、无效等价类和边界数据值；
+ 在对软件进行动态测试之前，一般应对软件单元的源代码进行静态测试；
+ 语句覆盖率达到100%；
+ 分支覆盖率达到100%；
+ 对输出数据及其格式进行测试。

***

## 静态测试

### 静态测试概述

> 静态测试是在不运行软件的情况下对软件进行测试。通过对程序代码和文档进行检查，以发现可能存在的错误。

静态测试可以从编码规则检查、代码结构分析和代码评审三个方面来进行。编码规则检查是将在编码过程中的一些注意事项形成规则并使用相关的工具进行检查；代码结构分析是使用工具对代码结构进行分析，避免代码过于复杂；代码评审则是由人对代码进行阅读，以发现代码中的一些潜在的错误。

### 编码规则检查

一般来说，将编译器的*警告等级设置到最高时*能够发现大部分的问题，所以在开发过程中首先需要将编译器的警告等级设置到最高然后消除编译器报告的所有警告。消除了编译器的所有警告后，代码可靠性已经是比较高的了，如果需要进一步提高代码的可靠性，可以通过专业的编码规则检查工具进一步检查。
可以选择**pc-lint**作为编码规则检查工具。与其他工具相比，**pc-lint**的检查更为全面，其中也集成了很多的行业标准。

### 预防Bug的十大编码规则

规则1：始终使用大括号
规则2：尽可能使用const关键字
规则3：尽可能使用static关键字
规则4：尽可能使用volatile关键字
规则5：不要注释掉代码
规则6：使用固定宽度的类型
>开发者在编写代码的过程中应该使用固定宽度的数据类型（int8_t，int16_t，int32_t，int64_t），以方便代码移植。

规则7：不要使用移位运算操作有符号数
规则8：有符号和无符号类型不要混用
规则9：尽量不要使用函数功能的宏
规则10：每行只定义一个变量

### 代码结构分析

在编写代码时，要求要结构清晰、接口简单。使用**SourceMonitor**作为代码结构检查工具。
![sourceMonitor](./images/sourceMonitor1.PNG)
然后在右键菜单中选择*Display CheckPoint Metrics Kiviat Graph*，查看某个检车点是否超标？
![sourceMonitor](./images/sourceMonitor2.PNG)

## 代码评审

代码评审有**代码走查**和**代码审查**两种方式。
> 代码走查是在评审人员充分理解了程序的意图后，设计测试用例，并由人充当计算机的角色，模拟计算机运行程序，以发现程序中的逻辑错误。

**代码走查**：

+ 首先将评审的材料发送给评审小组相关的成员，让评审小组充分理解程序的意图。评审材料包括需求文档、设计文档和软件代码。
+ 在评审小组各成员充分理解程序的意图后，设计测试用例，以小组为单位充当计算机的角色，按照测试用例的要求模拟计划机运行程序，在运行过程中大家进行必要的讨论。

代码走查与动态测试类似，都是使用测试用例运行程序。其区别是，代码走查并不是真正运行程序，而是以人充当计算机的角色模拟运行程序，能够很容易的覆盖到动态测试由于条件限制无法模拟的情况，但对人的逻辑思维能力要求也会比较高。

> 代码审查是评审员在充分理解了程序的意图后，通过阅读程序代码或由开发者讲解代码的方式，以发现程序中潜在的错误。

**代码审查**：

+ 需求确认：审查的第一项内容是程序代码是否正确实现了需求文档中的要求。
+ 设计确认：审查的第二项内容是程序是否与设计文档中的要求相符。
+ 代码规范：在确保程序代码正确实现需求且与设计文档相符后，接下来就可以对照代码规范对代码进行评审了。
+ 讨论环节：代码的效率足够高吗？代码的安全性足够高吗？代码方便后续维护吗？代码方便后续扩展吗？代码方便在其他项目中复用吗？代码是否考虑到了所有的异常情况？

**什么时候评审**？
建议的做法是从项目一开始编码就进行代码评审，每天下班前进行一次评审，针对当天编写或修改的代码。这种方式下每次评审的代码量不会很多，更容易达到效果；另外由于较早的开始进行评审，能够及时发现问题并进行修改，也能够更快的帮助开发者养成良好的编程习惯，尽可能的减少代码的返工率。

**评审哪些代码**？
在进行代码评审的时候，功能代码需要进行代码走查和代码审查，而测试代码需要进行代码审查。
***

## 测试用例设计

什么是测试用例？
> 一个测试用例描述了测试人员模拟用户使用系统的一个场景。在这个场景中，测试人员模拟用户的输入，并检测系统的输出是否与用户的期待输出是否一致。

在测试的过程中，实际上就是要控制被测模块的输入，检查被测模块的输出。所以输入输出的定义在测试过程中是至关重要的，如果输入输出定义错了，那么测试将变得无意义。
![输入输出定义](./images/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E5%AE%9A%E4%B9%89.PNG)

### 逻辑覆盖

什么是逻辑覆盖？
> 逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法，其目的是为了尽可能的覆盖程序的语句以及不同的判定条件。

+ **语句覆盖**的含义是，选择足够多的测试数据，使得程序中的每种语句都至少被执行一次。
+ **判定覆盖**的含义为，选择足够多的测试数据，使得程序中的每个判断语句至少出现一次真值和一次假值。
+ **条件覆盖**的定义为，当一个判定语句由多个条件组合而成时，选择足够多的测试数据，使得每一判定语句中的每个逻辑条件的可能的值至少出现一次。
+ **条件组合覆盖**的含义是，当一个判定语句由多个条件组合而成时，选择足够多的测试数据，使得各个条件的各种可能的组合都出现一次。

条件组合覆盖是覆盖率最高的一种逻辑覆盖方法。条件组合覆盖的缺点是测试数据的数量会很多。

**修正条件判定覆盖**的含义是，画出程序的控制流，选择足够多的测试数据，使得程序控制流中的每一条路径都执行一次。
![修正条件判定覆盖](./images/%E4%BF%AE%E6%AD%A3%E6%9D%A1%E4%BB%B6%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96.PNG)

### 数据覆盖

逻辑覆盖能够有效的发现问题。然而逻辑覆盖自身的缺点也是非常明显的。在使用逻辑覆盖的方法设计测试用例时，对实现的依赖性太高，以至于开发者很难考虑到代码本身没有考虑到的地方。

所以在进行单元测试的过程中，除了要使用逻辑覆盖之外，还需要使用另外的方法，那就是数据覆盖。只有两种方法同时使用，相互补充，才能最大限度的提高测试的覆盖率。

**边界值分析**在黑盒测试中经常被用到，在单元测试中也可以使用边界值分析来设计测试用例。通过大量的测试工作经验得知，应用程序往往容易在处理边界条件时发生错误，所以在测试过程中，通常也可以使用边界条件进行测试，只要边界条件没有问题，那么在数据范围内部出现问题的可能性是非常小的。
![分界点](./images/%E5%88%86%E7%95%8C%E7%82%B9.PNG)

输入值可以分为几个不同的集合，每个集合触发不同的处理流程，而每个集合中的各个值也不一定是连续的，在这种情况下无法直接使用边界值进行分析，那么就需要使用到**等价类划分**。

当输入值可以划分为几个不同的集合，而每个集合又触发不同的处理流程时，那么每个集合就可以称为一个等价类，从一个等价类中选取少量的用例就可以代表该等价类中所有可能的输入。

在有些时候，被测单元可能的输入值为有限个离散的值，而一时之间又很难找出规律。在这种情况下可以对所有可能的输入值进行**穷举**，以达到完全覆盖。
***

## 测试准备工作

### 单元测试框架

什么是单元测试框架？
> 单元测试框架是一个软件包，它能够让开发者比较方便的表达产品代码需要表现出什么样的行为。单元测试框架提供了一个自动化单元测试的解决方案，让开发者把更多的精力放在测试用例的设计的编写上，而不用花精力考虑如何对测试用例进行组织。

单元测试框架提供了以下功能：

+ 用于表达一个测试用例的通用语言；
+ 用于表达测试用例的期望结果的通用语言；
+ 对所有的测试用例进行有效的管理；
+ 提供运行部分或全部测试用例的机制；
+ 对于测试通过和失败给出明确的提示；
+ 对于失败的测试用例给出详细的报告；
+ 对各个测试用例的结果进行统计分析。
  
### gtest框架

gtest是google公司开发的一个开源的单元测试框架，基于C++开发，可以对C++语言和C语言进行单元测试。gtest有以下特点：

+ 提供强大的断言集，支持布尔型、整型、浮点型、字符串以及所有实现了比较运算符和输出运算符的自定义类的判断；
+ 提供断言扩展功能，当所需要的断言在gtest中没有提供时，可以使用gtest提供的方法进行扩展；
+ gtest会自动收集我们的测试用例，开发者不需要对测试用例进行组织；
+ 提供死亡测试的功能，用于测试代码在特定情况下异常崩溃的情况；
+ 可将公共的用例初始化和清理工作放入测试夹具中，由gtest自动调用；
+ 使用参数化自动生成多个相似的测试用例。

gtest可以通过[gtest源码](https://github.com/google/googletest/releases/tag/release-1.8.0)获取。
下载源码解压后，可以得到*googlemock*和*googletest*两个目录文件，其中*googletest*的内容就是gtest的源码及相关的项目文件。
![gtest目录文件](./images/gtest%E6%BA%90%E6%96%87%E4%BB%B6.PNG)

### Visual Studio 2013测试环境搭建

什么是库文件？
> 在实际编程的时候，通常需要对部分代码进行复用。可以把需要复用的代码单独进行编译，得到的文件就是库文件。库文件可以分为**静态库**和**动态库**。

**静态库**由一个lib文件（后缀名为.lib）组成，其中包含了对应代码的具体的实现。在编写应用程序时，只需要将lib文件链接到应用程序中就可以使用它的功能了;**动态库**由一个dll文件（后缀名为.dll）和一个lib文件组成，dll文件包含了对应代码的具体实现，而lib文件则包含了对应代码的入口地址。需要将lib文件链接到应用程序中，应用程序在启动后加载对应的dll文件，就可以使用它的功能了。

无论是静态运行库还是动态运行库，Visual Studio都提供了**Debug版本**和**Release版本**。其中Debug版本的运行库中包含了调试信息，Release版本的运行库中不包含调试信息；Debug版本的运行库是没有经过代码优化的，Release版本的运行是经过代码优化的。

[vs2019自带googleTest框架，只需要在工程中使能。](https://blog.csdn.net/weixin_43856003/article/details/105833925?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105833925-blog-124660326.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105833925-blog-124660326.pc_relevant_aa&utm_relevant_index=5)
***

## 编写测试代码

### 测试入口-main函数

```C
#include <gtest/gtest.h>

int main(int argc, char** argv)
{
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

testing::InitGoogleTest(&argc, argv)是使用命令行参数来初始化gtest。

### 表达测试用例的通用语言

测试用例
> 测试用例是为了验证代码的行为与预期是否相符而进行的一系列活动，在单元测试中，这一系列的活动依靠代码来完成。

测试用例集
> 测试用例集是多个相似或相关的测试用例的集合，是为了方便对测试用例进行管理而产生的一个概念。通俗一点讲，测试用例集就是对测试用例进行分组。

在gtest中，使用test case表示测试用例集，test表示测试用例，要注意区别。

### 通用的判断机制

测试用例的三大要素是**前提条件**、**操作步骤**和**预期结果**。测试用例是否通过的标准就是实际结果与预期结果是否相符，实际结果与预期结果相符则测试通过，实际结果与预期结果不相符则测试不通过。

gtest中判断实际结果与预期结果是否相符的机制称为断言。gtest提供了判断各种简单类型数据的断言，包括布尔类型、整数类型、浮点数类型、字符串等。

**布尔类型**判断
![布尔类型判断](./images/%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.PNG)

```C
TEST(IsLeapYearTest, leapYear)
{
    EXPECT_TRUE(IsLeapYear(2000));
    EXPECT_TRUE(IsLeapYear(1996));   
}

TEST(IsLeapYearTest, commonYear)
{
    EXPECT_TRUE(IsLeapYear(1999));
    EXPECT_TRUE(IsLeapYear(2100));   
}
```

**数值类型**判断
![数值类型判断](./images/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.PNG)

```C
TEST(IntSwapTest, swapSuccess)
{
    int a = 1;
    int b = 2;
    int_swap(&a, &b);
    EXPECT_EQ(2, a);
    EXPECT_EQ(1, b);   
}

TEST(IsLeapYearTest, commonYear)
{
    int a = 1;
    int_swap(&a, NULL);
    EXPECT_EQ(1, a);
    int_swap( NULL, &a);
    EXPECT_EQ(1, a); 
}
```

**浮点数**判断
![浮点数判断](./images/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD.PNG)

```C
TEST(SqrtTest, normalTest)
{
    EXPECT_NEAR(1e-50, sqrt(1e-100), 1e-12);
    EXPECT_NEAR(1, sqrt(1), 1e-12);
    EXPECT_NEAR(1e50, sqrt(1e100), 1e-12);   
}
```

**字符串**判断
![字符串1判断](./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD1.PNG)
![字符串2判断](./images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD2.PNG)

```C
TEST(ByteSwapTest, stringSwap)
{
    char str1[10] = "123456789";
    char str2[10] = "abcdefghi";
    byte_swap(str1, str2, 5);
    EXPECT_STREQ("abcde6789", str1);
    EXPECT_STREQ("12345fghi", str2);
}
    
TEST(ByteSwapTest, paramError)
{
   char str1[10] = "123456789";
   char str2[10] = "abcdefghi";
   byte_swap(str1, NULL,5);
   byte_swap(NULL, str2,5);
   byte_swap(str1 str2, 0);
   EXPECT_STREQ("123456789", str1);
   EXPECT_STREQ("abcdefghi", str2); 
}
```

**异常**判断
![字符串1判断](./images/%E5%BC%82%E5%B8%B8%E5%88%A4%E6%96%AD.PNG)

```C
TEST(SqrtTest, overRange)
{
    EXPECT_THROW(sqrt(1.00000001e100), int);
    EXPECT_THROW(sqrt(9.99999999e-101), int);
    EXPECT_THROW(sqrt(0), int);
    EXPECT_THROW(sqrt(-1), int);
}
```

在有些时候，当断言判断失败时，开发者可能需要附加输出一些信息以方便定位Bug。gtest在定义断言时重载了“<<”运算符，可以使用该运算符在gtest的输出信息中加入需要的信息。

```C
TEST(IsLeapYearTest, leapYear)
{
    EXPECT_TRUE(IsLeapYear(2000)) << "expect 2000 is leapyear";
    EXPECT_TRUE(IsLeapYear(1996)) << "expect 1996 is leapyear";   
}

TEST(IsLeapYearTest, commonYear)
{
    EXPECT_TRUE(IsLeapYear(1999)) << "expect 1999 is commonyear";
    EXPECT_TRUE(IsLeapYear(2100)) << "expect 2100 is commonyear";   
}
```

**自定义断言**
![自定义断言](./images/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80.PNG)

```C
void bubblesort(int* data, int len)
{
    int tem = 0;

    for (size_t i = 0; i < len; i++)
    {
        for (size_t j = i+1; j < len; j++)
        {
            if (data[i] > data[j])
            {
                tem = data[i];
                data[i] = data[j];
                data[j] = tem;
            }
        }
    }
}

bool ArrayCompare(const int *exp, const int *act, int len)
{
    bool flag = true;
    for (int i = 0; i < len; i++)
    {
        if (exp[i] != act[i])
        {
            flag = false;
            break;
        }
    }
    return flag;
}

TEST(BubbleSortTest, normalTest) 
{
    int expArray[5] = { 1, 2, 3, 4, 5};
    int actArray[5] = { 3, 1, 5, 4, 2 };

    bubblesort(actArray, 5);
    EXPECT_PRED3(ArrayCompare, expArray, actArray, 5);
}
```

可以使用**EXPECT_PRED3**来实现自定义断言以对数组进行比较，3的意思就是比较函数的参数为3个。使用**EXPECT_PRED3**时，第一个参数是比较函数的名字，之后三个参数是传入到比较函数的参数。

EXPECT开头和ASSERT开头对比
实际上，每一个EXPECT开头的断言都有一个对应的ASSERT开头的判断，例如EXPECT_EQ对应的有ASSERT_EQ。在使用EXPECT系列断言时，当判断失败时，gtest会继续后面的操作，这样就能一次性发现更多的错误。在某些时候，当判断失败时，gtest不需要再进行后续的操作，例如先判断指针是否为空再判断指针指向的内容，显然当指针为空时不需要再判断指针指向的内容。那么在这种情况下就可以使用ASSERT系列断言。值得注意的是，ASSERT系列断言在判断失败时不一定是结束当前用例，而是结束当前函数。

### 测试夹具

在编写一些比较复杂的用例时，通常会进行以下四个步骤的工作：

+ **初始化环境**：在编写测试用例时，有些用例需要在某些特定的前提条件下执行，所以需要进行初始化操作使系统处于特定的状态以便执行测试用例；
+ **运行**：使用特定的数据运行被测试代码；
+ **验证结果**：测试代码运行结束后对被测试代码返回的数据进行验证；
+ **清理现场**：为了不影响其他用例的执行，测试完成后需要将系统状态还原到初始状态。
  
当需要在一个用例集中每一个用例执行之前都进行初始化操作，在每一个用例执行之后都进行清理操作，那么可以将这部分操作放入测试夹具中。

```C++
class CSlistTest: public testing::Test
{
public:
    virtual void SetUp()
    {
        m_head.p_next = &m_node1;
        m_node1.p_next = &m_node2;
        m_node2.p_next = &m_node3;
        m_node3.p_next = NULL;
    }
    virtual void TearDown()
    {

    }
    slist_head_t m_head;
    slist_node_t m_node1;
    slist_node_t m_node2;
    slist_node_t m_node3;
};
```

测试夹具代码。

```C++
TEST_F(CSlistTest, getFirstNext)
{
    EXPECT_EQ(&m_node2, slist_next_get(&m_head, &m_node1));
}
TEST_F(CSlistTest,getLastNext)
{
    EXPECT_EQ(NULL, slist_next_get(&m_head, &m_node3));
}
```

在某些情况下，并不需要在每个用例执行前后都进行初始化和清理操作，只需要在用例集执行前进行初始化操作，在用例集执行后进行清理操作即可。

```C++
class CSlistTest: public testing::Test
{
public:
    virtual void SetUpTestCase()
    {
        m_head.p_next = &m_node1;
        m_node1.p_next = &m_node2;
        m_node2.p_next = &m_node3;
        m_node3.p_next = NULL;
    }
    virtual void TearDownTestCase()
    {

    }
    slist_head_t m_head;
    slist_node_t m_node1;
    slist_node_t m_node2;
    slist_node_t m_node3;
};
slist_head_t CSlistTest::m_head;
slist_head_t CSlistTest::m_node1;
slist_head_t CSlistTest::m_node2;
slist_head_t CSlistTest::m_node3;
```

在某些情况下，不需要在每个用例执行前进行初始化和清理操作，也不需要在每个用例集执行前后都进行初始化和清理操作。只需要在整个测试开始之前执行初始化操作，在整个测试结束后执行清理操作，在这种情况下可以使用全局测试夹具来完成。

```C++
class GlobalEnvironment : public testing::Environment
{
public:
    virtual void SetUp()
    {
        //todo:测试开始前的初始化动作
    }
    virtual void TearDownTestCase()
    {
        //todo：测试结束后的清理动作
    }
};
```

要使用全局测试夹具，只需要在main函数中调用RUN_ALL_TESTS()之前添加如下的代码即可：

```C++
testing :: AddGlobalTestEnvironment(new GlobalEnvironment( ));
```

在进行初始化操作时，执行顺序是全局初始化→用例集初始化→用例初始化；在进行清理操作时，执行顺序是用例清理→用例集清理→全局清理。
![测试夹具的动作顺序](./images/%E6%B5%8B%E8%AF%95%E5%A4%B9%E5%85%B7%E4%B8%AD%E5%90%84%E5%8A%A8%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.PNG)
***

## 仿制对象

### 什么是仿制对象

> 仿制对象是这样的一种对象，它模拟被测模块依赖的下层模块给被测模块提供数据，同时检查被测模块传递给下层模块的数据，同时提供测试用例控制的接口并为测试用例返回状态。

仿制对象的三大功能：

+ 以输出参数和返回值的方式为被测模块提供数据；
+ 检查被测模块调用下层模块时传递的参数；
+ 提供与测试用例交互的接口。

![仿制对象](./images/%E4%BB%BF%E5%88%B6%E5%AF%B9%E8%B1%A1.PNG)
***

## 轻量级测试框架-Unity

Unity是一个轻量级的测试框架，它使用C语言实现，代码本身很小，不到200K。由于Unity的代码中大多数是宏定义，所以实际编译后的代码会更小，比较适合在嵌入式测试应用。

### Unity配置

登入[Unity源码](http://www.github.com/ThrowTheSwitch/Unity/releases)获取源码。

将下载后的压缩包进行解压，可以看到里面的目录结构。
![Unity文件结构](./images/Unity%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.PNG)
打开src文件，里面有三个文件：unity.c、unity.h和unity_internals.h，在配置工程时，需要将src目录添加到目录中，同时将unity.c添加到工程中，即可使用Unity编写测试代码。

### 编写测试用例

在Unity中，每个测试用例都是一个函数，该函数没有参数和返回值。

```C
#include "leapyear.h"
#include "unity.h"

/* init function */
void setUp(void)
{

} 

/* clear function */
void tearDown(void)
{

}

/* test list1 */
void leapYear()
{
    TEST_ASSERT_TRUE(isLeapYear(2000));
    TEST_ASSERT_TRUE(isLeapYear(1996));
}

/* test list2 */
void commonYear()
{
    TEST_ASSERT_FALSE(isLeapYear(1999));
    TEST_ASSERT_FALSE(isLeapYear(2100));
}

int main(int argc, char *argv[]) 
{
    RUN_TEST(leapYear);
    RUN_TEST(commonYear);

    return 0;
}
```

Unity默认需要实现用例初始化函数setUp和用例清理函数tearDown，这两个函数均没有参数和返回值。
![unity测试结果](./images/Unity%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.PNG)

### 断言

布尔类型比较
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT(condition) | condition必须为真 |
| TEST_ASSERT_TRUE(condition) | condition必须为真 |
| TEST_ASSERT_UNLESS(condition) | condition必须为假 |
| TEST_ASSERT_FALSE(condition) | condition必须为假 |

指针比较
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_NULL(pointer) | pointer必须为空指针 |
| TEST_ASSERT_NOT_NULL(pointer) | pointer必须为非空指针 |
| TEST_ASSERT_EQUAL_PTR(expected, actual) | 指针actual必须和expected相等 |
| TEST_ASSERT_EQUAL_PTR_ARRAY(expected, actual, num_elements) | expected和actual都是有num_elements个元素的指针数组，要求每个对应的元素相等 |
| TEST_ASSERT_EACH_EQUAL_PTR(expected, actual, num_elements) | expected是指针，actual是有num_elements个元素的指针数组，要求actual中的每个元素都和expected相等 |

整数比较
整数必须等于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EQUAL_INT(expected, actual) | 两个数均为int类型 |
| TEST_ASSERT_EQUAL(expected, actual) | 两个数均为int类型 |
| TEST_ASSERT_EQUAL_INTn(expected, actual) | 两个数均为n位有符号整数 |
| TEST_ASSERT_EQUAL_UINT(expected, actual) | 两个数均为uint类型 |
| TEST_ASSERT_EQUAL_HEX(expected, actual) | 两个数均为uint类型 |
| TEST_ASSERT_EQUAL_UINTn(expected, actual) | 两个数均为n位无符号整数 |
| TEST_ASSERT_EQUAL_HEXn(expected, actual) | 两个数均为n位无符号整数 |

整数不能等于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_NOT_EQUAL(expected, actual) | 两个数均为整数，不限位数 |

对位进行判断
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_BITS(mask, expected, actual) | mask&actual必须和mask&expected相等 |
| TEST_ASSERT_BITS_HIGH(mask, actual) | mask&actual必须和mask相等 |
| TEST_ASSERT_BITS_LOW(mask, actual) | mask&actual必须为0 |
| TEST_ASSERT_BIT_HIGH(bit, actual) | actual的第bit位必须为1 |
| TEST_ASSERT_BIT_LOW(bit, actual) | actual的第bit位必须为0 |

整数必须大于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_GREATER_THAN(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_GREATER_THAN_INT(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_GREATER_THAN_INTn(threshold, actual) | 两个数均为n位有符号整数 |
| TEST_ASSERT_GREATER_THAN_UINT(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_GREATER_THAN_HEX(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_GREATER_THAN_UINTn(threshold, actual) | 两个数均为n位无符号整数 |
| TEST_ASSERT_GREATER_THAN_HEXn(threshold, actual) | 两个数均为n位无符号整数 |

整数必须小于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_LESS_THAN(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_LESS_THAN_INT(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_LESS_THAN_INTn(threshold, actual) | 两个数均为n位有符号整数 |
| TEST_ASSERT_LESS_THAN_UINT(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_LESS_THAN_HEX(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_LESS_THAN_UINTn(threshold, actual) | 两个数均为n位无符号整数 |
| TEST_ASSERT_LESS_THAN_HEXn(threshold, actual) | 两个数均为n位无符号整数 |

整数不能小于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_GREATER_OR_EQUAL (threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_GREATER_OR_EQUAL_INT(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_GREATER_OR_EQUAL_INTn(threshold, actual) | 两个数均为n位有符号整数 |
| TEST_ASSERT_GREATER_OR_EQUAL_UINT(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_GREATER_OR_EQUAL_HEX(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_GREATER_OR_EQUAL_UINTn(threshold, actual) | 两个数均为n位无符号整数 |
| TEST_ASSERT_GREATER_OR_EQUAL_HEXn(threshold, actual) | 两个数均为n位无符号整数 |

整数不能大于指定值
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_LESS_OR_EQUAL (threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_LESS_OR_EQUAL_INT(threshold, actual) | 两个数均为int类型 |
| TEST_ASSERT_LESS_OR_EQUAL_INTn(threshold, actual) | 两个数均为n位有符号整数 |
| TEST_ASSERT_LESS_OR_EQUAL_UINT(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_LESS_OR_EQUAL_HEX(threshold, actual) | 两个数均为uint类型 |
| TEST_ASSERT_LESS_OR_EQUAL_UINTn(threshold, actual) | 两个数均为n位无符号整数 |
| TEST_ASSERT_LESS_OR_EQUAL_HEXn(threshold, actual) | 两个数均为n位无符号整数 |

整数必须接近指定值
要求actual和expected相比，误差不能大于delta。
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_INT_WITHIN(delta, expected, actual) | 三个数均为int类型 |
| TEST_ASSERT_INTn_WITHIN(delta, expected, actual) | 三个数均为n位有符号整数 |
| TEST_ASSERT_UINT_WITHIN(delta, expected, actual) | 三个数均为uint类型 |
| TEST_ASSERT_HEX_WITHIN(delta, expected, actual) | 三个数均为uint类型 |
| TEST_ASSERT_UINTn_WITHIN(delta, expected, actual) | 三个数均为n位无符号整数 |
| TEST_ASSERT_HEXn_WITHIN(delta, expected, actual) | 三个数均为n位无符号整数 |

两个数组必须相等
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, num_elements) | 数组类型为int |
| TEST_ASSERT_EQUAL_INTn_ARRAY(expected, actual, num_elements) | 数组类型为n位有符号整数 |
| TEST_ASSERT_EQUAL_UINT_ARRAY(expected, actual, num_elements) | 数组类型为uint |
| TEST_ASSERT_EQUAL_HEX_ARRAY (expected, actual, num_elements) | 数组类型为uint |
| TEST_ASSERT_EQUAL_UINTn_ARRAY(expected, actual, num_elements) | 数组类型为n位无符号整数 |
| TEST_ASSERT_EQUAL_HEXn_ARRAY (expected, actual, num_elements) | 数组类型为n位无符号整数 |

数组中所有元素必须与指定值相等
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EACH_EQUAL_INT(expected, actual, num_elements) | 数组类型为int |
| TEST_ASSERT_EACH_EQUAL_INTn(expected, actual, num_elements) | 数组类型为n位有符号整数 |
| TEST_ASSERT_EACH_EQUAL_UINT(expected, actual, num_elements) | 数组类型为uint |
| TEST_ASSERT_EACH_EQUAL_HEX(expected, actual, num_elements) | 数组类型为uint |
| TEST_ASSERT_EACH_EQUAL_UINTn(expected, actual, num_elements) | 数组类型为n位无符号整数 |
| TEST_ASSERT_EACH_EQUAL_HEXn(expected, actual, num_elements) | 数组类型为n位无符号整数 |

字符串
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EQUAL_STRING(expected, actual) | 字符串actual必须和expected相等 |
| TEST_ASSERT_EQUAL_STRING_LEN(expected, actual, len) | 两个字符串的前len个字符相等 |
| TEST_ASSERT_EQUAL_STRING_ARRAY(expected, actual, num_elements) | actual和expected均为字符串数组每个数组中包含num_elements个字符串两个数组中的每个字符串都必须相等 |
| TEST_ASSERT_EACH_EQUAL_STRING(expected, actual, num_elements) | actual为包含num_elements个字符串的数组actual中的每字符串都必须和字符串expected相等 |

浮点数比较
浮点数相等并要求真的相等。在Unity中，单精度浮点数actual与expected的误差在1e-5范围内认为是相等；双精度浮点数actual与expect的误差在1e-12范围内认为是相等。
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EQUAL_FLOAT(expected, actual) | 单精度 |
| TEST_ASSERT_EQUAL_DOUBLE(expected, actual) | 双精度 |
| TEST_ASSERT_FLOAT_WITHIN(delta, expected, actual) | 单精度 |
| TEST_ASSERT_DOUBLE_WITHIN(delta, expected, actual) | 双精度 |
| TEST_ASSERT_EQUAL_FLOAT_ARRAY(expected, actual, num_elements) | 单精度 |
| TEST_ASSERT_EQUAL_DOUBLE_ARRAY(expected, actual, num_elements) | 双精度 |
| TEST_ASSERT_EACH_EQUAL_FLOAT(expected, actual, num_elements) | 单精度 |
| TEST_ASSERT_EACH_EQUAL_DOUBLE(expected, actual, num_elements) | 双精度 |

Unity还实现了浮点数有效性的判断，这类断言可以判断可以判断一个浮点数是否为无穷大或无效值。
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_FLOAT_IS_INF(actual) | actual为正无穷 |
| TEST_ASSERT_DOUBLE_IS_INF(actual) | actual为正无穷 |
| TEST_ASSERT_FLOAT_IS_NEG_INF(actual) | actual为负无穷 |
| TEST_ASSERT_DOUBLE_IS_NEG_INF(actual) | actual为负无穷 |
| TEST_ASSERT_FLOAT_IS_NAN(actual) | actual为无效值（比如负数开根） |
| TEST_ASSERT_DOUBLE_IS_NAN(actual) | actual为无效值（比如负数开根） |
| TEST_ASSERT_FLOAT_IS_DETERMINATE(actual) | actual为正常值 |
| TEST_ASSERT_DOUBLE_IS_DETERMINATE(actual) | actual为正常值 |
| TEST_ASSERT_FLOAT_IS_NOT_INF(actual) | actual不为正无穷 |
| TEST_ASSERT_DOUBLE_IS_NOT_INF(actual) | actual不为正无穷 |
| TEST_ASSERT_FLOAT_IS_NOT_NEG_INF(actual) | actual不为负无穷 |
| TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF(actual) | actual不为负无穷 |
| TEST_ASSERT_FLOAT_IS_NOT_NAN(actual) | actual不为无效值 |
| TEST_ASSERT_DOUBLE_IS_NOT_NAN(actual) | actual不为无效值 |
| TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE(actual) | actual不为正常值 |
| TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE(actual) | actual不为正常值 |

内存段比较
| 断言 | 说明 |
| :-----: | :----: |
| TEST_ASSERT_EQUAL_MEMORY(expected, actual, len) | 两段内存的内容必须相同，起始地址分别为expected和actual，长度均为len |
| TEST_ASSERT_EQUAL_MEMORY_ARRAY(expected, actual, len, num_elements) | expected和actual中均有num_elements个大小为len的内存块，要求每个对应的块的内容相同 |
| TEST_ASSERT_EACH_EQUAL_MEMORY(expected, actual, len, num_elements) | expected为一个大小为len的内存块actual为num_elements个大小为len的内存块要求actual中每一块的内容都和expected相同 |

### 移植

Unity的移植非常简单，只需要实现一个头文件unity_config.h，并将与平台相关的特性写入unity_config.h中；然后在Unity的unity_internals.h文件的开始处加入如下的宏定义。

```C
/* 使能unity配置 */
#define UNITY_INCLUDE_CONFIG_H     

/* 数据宽度定义 */
#define UNITY_INT_WIDTH         32
#define UNITY_LONG_WIDTH        32
#define UNITY_POINTER_WIDTH     32

/* 64位支持 */
#define UNITY_SUPPORT_64

/* 解除float类型支持 */
#define UNITY_EXCLUDE_FLOAT

/* 添加double类型支持 */
#define UNITY_INCLUDE_DOUBLE

/* 浮点数判断误差定义 */
#define UNITY_FLOAT_PRECISION (0.00001f)
#define UNITY_DOUBLE_PRECISION (1e-12)

/* 字符输出函数声明 */
#define UNITY_OUTPUT_CHAR(a) output_char(a)
```

### 扩展功能

在Unity的主目录中，有一个extras目录，这里面就是Unity提供的扩展功能。在配置工程的时候，需要将src目录和extras\fixture\src添加到包含目录中，将unity.c和unity_fixture.c添加到工程中。

### 测试用例集

1、定义测试用例集
在Unity的扩展功能中，可以使用TEST_GROUP(suite_name)来定义一个测试用例集，使用TEST_SETUP(suite_name)定义用当前用例集的用例初始化操作，使用TEST_TEAR_DOWN(suite_name)定义当前用例集的用例清理操作。

```C
#include "unity_fixture.h"
#include "..\product_code\leapyear.h"

TEST_GROUP(isLeapYearTest)

TEST_SETUP(isLeapYearTest)
{

}
TEST_TEAR_DOWN(isLeapYearTest)
{

}
```

2、定义测试用例

```C
TEST(isLeapYearTest, leapYear)
{
    TEST_ASSERT_TRUE(isLeapYear(2000));
    TEST_ASSERT_TRUE(isLeapYear(1996));
}

TEST(isLeapYearTest, commonYear)
{
    TEST_ASSERT_FALSE(isLeapYear(1999));
    TEST_ASSERT_FALSE(isLeapYear(2100));
}
```

3、组织测试用例集
在Unity中，测试用例并不能直接运行，需要开发者自行将测试用例组织起来才能够运行，可以使用TEST_GROUP_RUNNER(suite_name)来组织一个测试用例集中的所有用例，同时使用RUN_TEST_CASE(suite_name, case_name)将各个测试用例添加到测试用例列表中以方便运行。

```C
TEST_GROUP_RUNNER(isLeapYearTest)
{
    RUN_TEST_CASE(isLeapYear, leapYear);
    RUN_TEST_CASE(isLeapYear, commonYear);
}
```

4、运行测试用例
在编写了测试用例并将测试用例有效的组织起来后，接下来就可以运行测试用例。首先需要实现一个全局函数，并在该函数中使用RUN_TEST_GROUP(suite_name)运行各个测试用例集，该函数的参数和返回值均为void。在main函数中调用UnityMain函数，并传入全局函数的地址以运行测试。

```C
static void RunAllTests()
{
    RUN_TEST_GROUP(isLeapYearTest);
}

int main(int argc, char *argv[]) 
{
    return UnityMain(argc, argv, RunAllTests);
}
```

### 命令行参数

*输出每个用例的名称*：可以在命令行参数中添加“-v”告诉Unity输出完整的测试用例的名称。

*筛选测试用例集*：可以使用命令行参数“-g suite_name”筛选指定的用例集执行，必须指定完整的测试用例集的名称，不能使用通配符。

*筛选测试用例*：可以使用使用行参数“-n case_name”筛选指定的用例执行，必须指定完整的测试用例名称，不能使用通配符。

*设置重复次数*：可以使用“-r num”指定测试运行的次数，指定了次数后测试将运行多次。
***

## 自动构建

### cmake概述

在实际开发过程中，还有一些问题是值得考虑的。

+ 在某些平台下，需要是使用make进行构建，使用make时除了需要手动编写各代码文件的依赖关系外，Makefile的语法也比较繁琐。Makefile中有很多默认规则，编写Makefile的时候必须十分谨慎，稍不注意就容易出错。而在开发过程中，每增加一个源文件都不得不去更改Makefile，使用也非常不方便。
+ 在开发一个跨平台的代码库时，需要针对代码库支持的每一个平台创建相应的项目文件或Makefile。维护这些项目文件或Makefile本身会有比较大的工作量。
+ 在多人协作开发时，每个人添加了源文件都需要更改项目文件或Makefile，在频繁修改项目文件或Makefile的情况下，提交代码到版本库时很容易导致冲突，从而影响开发效率。
+ 由于单元测试是需要持续进行的，开发者每天都需要进行编译、测试的过程，如果能够一键操作，将会大大减轻开发者的工作量。

这样一来就需要一种方式能够一键执行生成工程或Makefile、编译、测试的方法，实现构建自动化。

> cmake是一个跨平台的编译工具，开发者使用cmake语法编写跨平台的编译配置文件CMakeLists.txt，然后就可以生成不同编译环境的项目文件或Makefile。

cmake可以在官方页面[cmake链接](https://cmake.org/download)获取安装包或压缩包。

### cmake基本用法

在使用cmake时，首先需要编写一个CMakeLists.txt文件，然后执行cmake命令即可自动生成所需的项目文件或Makefile。

当只有一个源文件时，CMakeLists非常简单。

```C
#include <stdio.h>
#include <stdlib.h>

double power(double base, int exponent)
{
    double result = base;
    if (exponent == 0)
    {
        return 1;
    }
    
    for (int i = 0; i < exponent; i++)
    {
        result *= base;
    }
    
    return result;
}

int main(int argc, char** argv)
{
    if (argc < 3)
    {
        printf("Usage:%s base exponent\n", argv[0]);
        return 1;
    }
    
    double base = atof(argv[1]);
    int exponent = atoi(argv[2]);
    double result = power(base, exponent);
    printf("%g^%d is %g\n", base, exponent, result);

    return 0;
}
```

对应的CMakeLists.txt内容如下:

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

#工程名称
project(Demo1)

#项目信息
add_executable(Demo main.cc)
```

为了不污染代码的目录，可以创建一个build子目录，然后在build目录中执行如下的cmake命令。

```C
cmake ..
```

执行了cmake命令后，可以看到在build目录下已经生成了解决方案。
![cmake执行之后](./images/cmake%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C.PNG)

在命令行中使用命令行参数-G指定了编译器，使用“cmake --help”命令可以查看cmake支持的所有编译器。

```C
cmake -G "Unix Makefiles" ..
```

cmake变量定义及引用
在CMakeLists.txt中，可以定义一些变量以方便后续使用，使用set函数可定义变量，如变量在之前已定义，则可修改变量的值。

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

#工程名称
project(Demo1)

#定义变量
set(DIR_SRCS main.c)
set(DIR_SRCS ${DIR_SRCS} MathFunctions.cc)

#项目信息
add_executable(Demo ${DIR_SRCS})
```

源文件扫描
在添加一个项目时，需要指定源文件列表，当源文件比较多时，一个一个的添加难免会有所遗漏。cmake支持扫描一个目录中的所有源文件，并把扫描到的源文件存放在一个变量中，后续可以直接使用这个变量创建项目。

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

#工程名称
project(Demo1)

#寻找当面目录下的所有源文件
aux_source_directory(. DIR_SRCS)

#项目信息
add_executable(Demo ${DIR_SRCS})
```

子模块
在实际开发过程中，有时候需要将不同模块的代码放入不同的目录中，同时需要每个模块都单独创建一个项目文件。可以在每个目录中单独存放一个CMakeLists.txt，然后在上层的CMakeLists.txt中使用add_subdirectory函数包含下层的CMakeLists.txt。

比如当需要将上述清单程序power函数单独写在另外一个文件MathFunctions.cc并放入一个单独的子目录math中时，则math目录下的CMakeLists的内容如下：

```C
#寻找当面目录下的所有源文件
aux_source_directory(. DIR_SRCS)

#项目信息
add_library(MathFunctions ${DIR_LIB_SRCS})
```

该工程编译成功后将生成一个静态库。如果需要生成一个动态库工程，那么在执行cmake命令时使用如下命令即可。

```C
cmake -DBUILD_SHARED_LIBS:BOOL=ON ..
```

main.cc所在的目录中的CMakeLists.txt需要使用add_subdirectory包含子目录。

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

# 工程名称
project(Demo1)

# 添加头文件路径
include_directory(math)

# 添加math子路径
add_subdirectory(math)

# 项目信息
add_executable(Demo main.cc)

# 添加链接库
target_link_libraries(Demo MathFunctions)
```

条件编译
在编写CMakeLists.txt时，可以在生成工程时决定是否在代码中定义指定的宏，以实现条件编译。一般情况下，可以宏定义在头文件中，而cmake可以自动生成头文件，这样就可以在生成头文件时决定是否需要定义对应的宏。

可以使用一个宏USE_MYMATH来决定main函数中是使用MathFunctions.cc中的power函数进行计算还是调用C标准库中的pow函数进行计算。

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

# 工程名称
project(Demo1)

# 定义选项并生成头文件
option(USE_MYMATH "Use provided math implementation" ON)
configure_file("${PROJECT_SOURCE_DIR}/config.h.in"
               "${PROJECT_SOURCE_DIR}/config.h")

# 是否加入MathFunctions库
if (USE_MYMATH)
    include_directories(math)
    add_subdirectory(math)
    set(EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)

# 项目信息
add_executable(Demo main.cc)

# 添加链接库
target_link_libraries(Demo ${EXTRA_LIBS})
```

`configure_file`第一个参数是生成头文件的规则的文件，第二个参数为要生成的头文件存放的路径。规则文件`config.h.in`内容为：

```C
#cmakedefine USE_MYMATH
```

如果USE_MYMATH选项为ON，则在生成的头文件config.h中含有宏USE_MYMATH的定义，否则在生成的头文件config.h不包含宏USE_MYMATH的定义。

为了实现条件编译，main.cc需要进行相应的修改。

```C
#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#ifdef USE_MYMATH
    #include "MathFunction.h"
#else
    #include "math.h"
#endif

int main(int argc, char** argv)
{
    if (argc < 3)
    {
        printf("Usage:%s base exponent\n", argv[0]);
        return 1;
    }
    
    double base = atof(argv[1]);
    int exponent = atoi(argv[2]);
#ifdef USE_MYMATH
    double result = power(base, exponent);
#else
    double result = pow(base, exponent);
#endif
    printf("%g^%d is %g\n", base, exponent, result);

    return 0;
}
```

默认是有宏USE_MYMATH定义的，如果不想定义这个宏，则执行cmake命令时使用如下的命令：

```C
cmake -DUSE_MYMATH=OFF ..
```

除了生成头文件外，cmake还可以在工程文件或Makefile中自动添加全局的宏定义，这样就可以不用生成对应的头文件。可以使用add_definitions添加一个全局宏定义，这样在代码中就可以直接使用这个全局宏定义进行条件编译。

```C
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

# 工程名称
project(Demo1)

# 定义选项并生成头文件
option(USE_MYMATH "Use provided math implementation" ON)

# 是否加入MathFunctions库
if (USE_MYMATH)
    include_directories(math)
    add_subdirectory(math)
    set(EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
    add_definitions(-DUSE_MYMATH)
endif (USE_MYMATH)

# 项目信息
add_executable(Demo main.cc)

# 添加链接库
target_link_libraries(Demo ${EXTRA_LIBS})
```

生成安装脚本
在有些时候，在编译完成后需要提取部分文件以便复用。例如在编译一个库文件工程时，需要在编译完成后提取生成的库文件以及所需的头文件。

```C
# 查找当前目录下的所有源文件
aux_source_directory(. DIR_LIB_SRCS)

# 生成链接库
add_library(MathFunctions ${DIR_LIB_SRCS})

# 安装文件
install (DIRECTORY "${PROJECT_SOURCE_DIR}/math"
        DESTINATION "include"
        FILES_MATCHING  
        PATTERN "*.h")

install (TARGETS MathFunctions
         RUNTIME DESTINATION bin
         ARCHIVE DESTINATION lib
         LIBRARY DESTINATION lib)
```

第二个install指定cmake将项目MathFunctions生成的二进制文件复制到安装位置。第一个参数指定复制项目MathFunctions生成的的文件；第二个参数指定可执行文件和动态库复制到安装目录下的bin子目录下；第三个参数指定扩展名为.a的静态库库文件复制到安装目录下的lib子目录下；第四个参数指定扩展名为.lib的库文件复制到安装目录下的lib子目录下。

在执行cmake命令时，需要指定安装目录，使用如下所示的命令指定安装位置为dist目录。

```C
cmake -DCMAKE_INSTALL_PREFIX:PATH=dist ..
```
